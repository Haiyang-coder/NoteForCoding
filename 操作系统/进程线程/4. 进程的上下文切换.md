**一个进程切换到另一个进程运行，称为进程的上下文切换**。

# cpu的上下文切换

任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。

所以，操作系统需要事先帮 CPU 设置好 ==**CPU 寄存器和程序计数器**==。**CPU 寄存器和程序计数是** CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 **CPU 上下文**。程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

CPU 上下文切换就是先把前一个任务的CPU上下文（CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。



# 进程上下文切换是切换的什么？

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

所以，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：

![image-20240426112502077](./page/image-20240426112502077.png)

# 什么时候会发生上下文切换

- 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，==当某个进程的时间片耗尽了==，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
- 进程在==系统资源不足==（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
- 当进程通过==睡眠函数 sleep==这样的方法将自己主动挂起时，自然也会重新调度；
- ==当有优先级更高的进程运行==时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
- ==发生硬件中断时==，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；