## 你怎么理解tcp是面向字节的传输协议这句话？

“TCP是面向字节的传输协议”这句话的意思是TCP协议传输数据时，并不关心数据的具体边界。它将数据视为一个连续的字节流，而不是分离的消息或数据包。这种设计方式带来了以下几点关键特性和影响：

1. **连续字节流**： TCP传输的数据被看作是一个连续的字节流，从发送端到接收端。在发送数据时，应用程序可以发送任意长度的数据，而TCP会将这些数据分割成适合传输的大小，然后再通过网络发送出去。
2. **数据分段和重组**： 在传输过程中，TCP将数据分段为较小的片段（通常称为TCP段或数据包），这些片段在网络中独立传输。在接收端，TCP会根据序列号将这些片段重新组装成原始的字节流，确保数据的完整性和顺序。
3. **数据无边界**： 由于TCP是面向字节流的，它并不知道也不关心应用层数据的边界。这意味着如果一个应用程序发送了两条消息，它们在接收端可能会被拼接在一起，或者一条消息可能被拆成多次接收。因此，应用程序需要自己定义和处理消息的边界。
4. **可靠传输**： TCP提供了可靠的传输服务，通过确认（ACK）、超时重传、流量控制和拥塞控制等机制，确保数据正确且有序地到达接收端。这些机制在字节流的基础上进行操作。

**实际应用中的例子**：

假设有一个客户端和服务器通过TCP连接进行通信。客户端发送了一段包含两个消息的数据：

```
Message 1: "Hello, Server."
Message 2: "How are you?"
```

在TCP层面，这两个消息会被作为一个连续的字节流发送，比如：

```
"Hello, Server.How are you?"
```

接收端接收到的数据可能是这样的：

```
"Hello, S"
"erver. Ho"
"w are you?"
```

因此，服务器应用程序需要根据协议或数据格式来解析并重新组合这些消息，以恢复原始的应用层消息。

总结来说，TCP的面向字节特性提供了灵活性，使得其能处理各种不同的数据传输需求，但也要求应用程序在处理消息边界时要额外小心。

## udp 面向消息的协议

UDP将数据作为独立的消息（也称为数据报，datagram）进行处理和传输，每个消息是一个完整的单元。以下是UDP面向消息特性的具体含义和关键特性：

1. **消息边界**： 在UDP中，每个数据报都是独立的，并且保留了发送时的边界。如果应用程序发送一个数据报，接收端会接收到一个完整的数据报，不会被拆分或合并。例如，如果发送端发送了三个独立的数据报，接收端将会分别收到这三个独立的数据报。
2. **无连接**： UDP是一个无连接协议，意味着在数据传输之前不需要建立连接。这使得UDP的开销较低，适用于需要快速传输小数据包的场景，例如实时音视频传输、在线游戏和DNS查询。
3. **不可靠传输**： UDP不提供像TCP那样的可靠性保障。它不保证数据报会被按顺序或完整地送达接收端，也没有重传机制。如果数据报在传输过程中丢失，UDP不会进行重传，应用程序需要自行处理数据的丢失或错误。
4. **无流量控制和拥塞控制**： UDP不实现流量控制和拥塞控制机制，数据报的发送频率和数量完全由应用程序控制。这意味着在网络拥塞时，UDP不会自动调整发送速率，可能导致数据包丢失或网络负载加重。

**实际应用中的例子**：

假设有一个客户端和服务器通过UDP进行通信。客户端发送了两个独立的消息：

```
Message 1: "Hello, Server."
Message 2: "How are you?"
```

在UDP层面，这两个消息会被分别作为独立的数据报发送：

- 数据报1: "Hello, Server."
- 数据报2: "How are you?"

接收端会分别接收到这两个数据报：

```
"Hello, Server."
"How are you?"
```

总结来说，UDP的面向消息特性使其在需要低延迟和较高吞吐量的应用中非常有用，尽管它不提供可靠性保障。因此，选择使用UDP还是TCP，需要根据具体应用的需求来决定。

## 多个 TCP 服务进程可以绑定同一个端口吗？

==**如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”**。==

注意，如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。

这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。



==**重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？**==

**当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误**。

而等 TIME_WAIT 状态的连接结束后，重启 TCP 服务进程就能成功。

我们可以在调用 bind 前，对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。

因为 SO_REUSEADDR 作用是：**如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功**。



**前面我提到过这个问题**：如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。

这个问题也可以由 SO_REUSEADDR 解决，因为它的**另外一个作用**：绑定的 IP地址 + 端口时，只要 IP 地址不是正好(exactly)相同，那么允许绑定。

比如，0.0.0.0:8888 和192.168.1.100:8888，虽然逻辑意义上前者包含了后者，但是 0.0.0.0 泛指所有本地 IP，而 192.168.1.100 特指某一IP，两者并不是完全相同，所以在对 socket 设置 SO_REUSEADDR 属性后，那么执行 bind() 时候就会绑定成功。

## 客户端的端口可以重复使用吗？

正确的理解是，**TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。**