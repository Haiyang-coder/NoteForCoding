[TOC]
# jvm 类的初始化

## 1.编译
在一开始的时候程序员写的java代码,即后缀为`.java`的文件,编译就形成了后缀为`.class`的字节码文件,`.class`文件如下图所示
```java
public java.lang.String getName();
     descriptor: ()Ljava/lang/String;
     flags: ACC_PUBLIC
     Code:
         stack=1, locals=1, args_size=1
             0: aload_0
             1: get_field    #2
             4: areturn
```
## 2.类加载
编译完成之后,就会被放到jvm内存中等待 **加载**,注意加载的时机,是在你用到这个类的时候加载,那谁负责加载呢?就是 **JVM中的类加载器**,类加载器加载类是一个非常复杂的过程,他用到了**字节码执行引擎**来加载类,类的加载也要经历几个过程,分别是
* 加载
* 验证
* 准备
* 解析
* 初始化
  
下面详细介绍四个部分

### (1).加载
程序启动后,会把main方法的主类加载到jvm内存,main方法中使用到了那个类在去把另一个类加载到内存->通过类的全限定名来获取类的二进制字节流,然后把二进制字节流转换成方法区的运行时数据结构,并在堆中创建对应的Class对象(此时的类成非静态成员有了初始值)。
### (2).验证
验证主要是验证字节码文件的语法是否满足规范,可以被字节码执行引擎所执行
### (3).准备
准备是把类中的类变量（也就是static修饰的变量）分配空间,并给他们一个初始值

### (4)解析
这个阶段干的事儿，实际上是把符号引用替换为直接引用的过程，其实这个部分的内容很复杂，涉及到JVM的底层,以后再来填坑

### (5)初试化
之前的准备阶段只是开辟了空间有了默认值,不是真正的初始化,现在会给类变量初始化(​ 静态变量赋值 -> 静态代码块 -> 成员变量 -> 构造代码块 -> 构造方法)

>以上是介绍的一个类的加载全流程,剩下的就是类的调用和销毁了,但是我们考虑到,java中类是有继承机制的,所以类加载器在初始化的时候会优先初始化他的父类(初始化子类前对父类走一遍全部流程).

## 3.双亲委派模型
>**双亲委派机制**:就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载.但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器,如下图所示:

![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/202210191035489.png)

>整体加载流程如下图:

![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/image-20220913152526157.png)

**双亲委派模型的作用**
1. 安全性,保护了系统类不能被修改
2. 性能,能够避免类被重复的加载

>当然你也可以自己的类加载器,继承实现**ClassLoad**类的方法,放弃双亲委派机制.

## 4.类加载器
 
### 启动类加载器(BootstrapClassLoader)
  > 加载java目录的核心类,就是你配置的jdk的那个lib
### 扩展类加载器(ExtensionClassLoader)现在换成了(PlatformClassLoader平台类加载器)
  >也是java目录下的拓展文件夹
### 应用类加载器(AppClassLoader)
  >加载应用级别的模块,还有ClassPath系统路径下的类
### 自定义类加载器
  >自己实现的加载器,如tomcat就不采用双亲委派机制
