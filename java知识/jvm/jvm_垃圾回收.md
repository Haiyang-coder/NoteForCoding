[TOC]
# jvm 垃圾回收
jvm垃圾回收:强应用不会回收,弱引用和软引用可能会被回收,看一下[java_引用类型](https://github.com/Haiyang-coder/NoteForJava/blob/main/java%E7%9F%A5%E8%AF%86/java_%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.md)

## 1.新生代垃圾回收算法---复制算法
>1. 将新生代分成两个区,新建的对象先放在同一个区里面,等到对象快放满了
>2. 对象快满了扫描,标记出不能回收的区域
>3. 将标记的不可回收的区域整体搬迁到另一个空白区域,清空之前的区域

- **优点**
可以有效的避免了内存碎片
- **缺点**
每次只能使用一般的年轻代

## 2.新生代垃圾回收算法---优化复制算法
<font color=red>1个Eden区，2个Survivor区</font>，其中Eden区占80%内存空间，每一块Survivor区各占10%内存空间，比如说Eden区有800MB内存，每一块Survivor区就100MB内

>1. 先放到Eden区里面,快满了在扫描,将存活的对象放到Survivor里面
>2. 又满了之后再次进行扫描,将存货的和Survivor区(也参加了扫描)一块放到另一个Survivor区里面

## 2.新生代何时进去老年代
* 在新生代中年龄15岁
* 动态年龄判断的规则:
> Survivor2区有两个对象，这俩对象的年龄一样，都是2岁然后俩对象加起来对象超过了50MB，超过了Survivor2区的100MB内存大小的一半了，这个时候，Survivor2区里的大于等于2岁的对象，就要全部进入老年代里去。
* 有一个JVM参数，就是“-XX:PretenureSizeThreshold”,超过这个数值直接进入老年代
* Eden区域中存活的对象太多了,无法放到另一块Survivor中,会直接放入老年代
## 3.老年代的空间分配担保规则
* 首先，在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小
* 假如Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了，就会看一个“-XX:-HandlePromotionFailure”的参数,有设置进入下一步
* 就是看看老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。
* 如果上面那个步骤判断失败了，或者的“-XX:-HandlePromotionFailure”参数没设置，此时就会直接触发一次“Full GC”，就是对老年代和年轻代进行垃圾回收，尽量腾出来一些内存空间，然后再执行Minor GC
* 如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的“OOM”内存溢出了

**<font color=red>总结老年代进行垃圾回收的时机</font>**
1. 在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC然后再带着进行Minor GC；
2. 在Minor GC之后，发现剩余对象太多放入老年代都放不下了。
![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/202210241049134.png)

## 4.老年代的垃圾回收算法---标记整理算法
1. 先标记出来老年代当前存活的对象
2. 接着会让这些存活对象在内存里进行移动，把存活对象尽量都挪动到一边去，让存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片
3. 然后再一次性把垃圾对象都回收掉

>老年代的垃圾回收算法的速度至少比新生代的垃圾回收算法的速度慢10倍。所以所谓JVM优化，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。

## 5.GCRoots(根搜索算法)
从根节点向下搜索对象节点,搜索走过的路称为引用链,当一个对象和根节点之间没有联通通路时则该对象不可用
![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/GCroots.png)
**哪些对象可以作为GCRoots**
- 方法区中类的静态变量指向的实例
- 方法的局部变量指向的实例对象.
- 方法区中常量的引用对象(final)