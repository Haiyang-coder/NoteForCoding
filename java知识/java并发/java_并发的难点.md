[TOC]
# 并发导致程序bug的源头

## 1.缓存导致的可见性问题
可见性:用我自己的话说,前面的操作对后面的操作是否是可见的.
>eg:不同线程修改同一个变量,前面一个线程修改完变量后的影响时候能被后面修改的线程可见.如果不可见,就会导致问题,后面修改的会无视前面的修改结果并覆盖变量的内存,相信大家都经常遇到这种问题

原因:**cpu,内存,io的速度相差真的是太大**了,为了协调速度不一致导致的算力的浪费,软硬件都做了很多的尝试
> - cpu增加了缓存,cpu的运算解过快速的写到缓存中去
>  - 操作系统增加了线程,进程,时分复用,从而更好的均衡cpu和io设备的速度差异
>  - 编译系统优化程序员的指令使得缓存可以更好的被利用

下面重点说一下缓存的代价
### (1).单核时代
在单核时代不存在可见性问题,因为只有一个cpu,只有一个缓存,不同的线程对数据的修改不存在可见性的问题,因为修改的是一个缓存
### (2).多核时代
多核时代,多个线程运行在不同的cpu上,导致修改的缓存不是同一个缓存,这是还行保持缓存之间的一致性就变的非常困难,想要保持一致性就是需要解决问题

## 2.线程切换带来的原子性问题
线程切换:为什么会有线程切换,一方面是操作的权限问题,管态和目态需要线程切换,另一方面,由于cpu太快了,所以相对于内存和io,cpu要处理不同程序来保证cpu的效率问题
>切换就带了重大的原子性问题,就是一个简单的代码`count++`,对于需要3条cpu指令
> - 从内存读
> - 修改内容
> - 写入内存
> 此时发生了线程的切换,另一个线程完成了这3步骤,切回去,之前的线程完成后后把结果覆盖了.导致了原子性问题

## 3.编译优化,带来了有序性问题
程序员写的代码是给人看的,为了易读性放弃了很多,翻译成机器码的时候需要编译器做出最有利于机器运行的机器码来提高代码运行的速度.优化的方式如改变程序的执行顺序等...
>如new的步骤
>- 分配一块内存M
>- 将M的地址赋值给变量
>- 在M地址上初始化对象

这里就会出现一个问题,你走到第二布的时候,这个变量被赋值了,就不是null了,但是是实际情况是,此时的变量所指的地址是空的.

