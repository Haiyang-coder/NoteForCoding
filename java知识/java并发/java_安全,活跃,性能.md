[TOC]

# 线程安全,活跃,性能

## 1.线程安全
本质上就是正确性，而正确性的含义就是程序按照我们期望的执行,出现线程不安全的情况是**存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据**,不是简单的加锁就可以做到没问题的,看下面这个例子
```java
public class Test {
public class Test {
  private long count = 0;
  synchronized long get(){
    return count；
  }
  synchronized void set(long v){
    count = v;
  } 
  void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      set(get()+1)      
    }
  }
}

```
假设 count=0，当两个线程同时执行 get() 方法时，get() 方法会返回相同的值 0，两个线程执行 get()+1 操作，结果都是 1，之后两个线程再将结果 1 写入了内存。你本来期望的是 2，而结果却是 1。这种问题，有个官方的称呼，叫<font color=red>竞态条件</font>，产生原因是
```java
if (状态变量 满足 执行条件) {
  执行操作
}
```
>在进入if里面的时候,条件的状态已经被另一个线程给修改了,这种情况其实也可以用锁的使用来解决问题.

## 2.活跃性问题

所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是“活锁”和“饥饿”
>有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。就是两个人相互谦让,导致谁也获取不到资源,解决的办法就是设置一个谦让的随机事件,避免冲突

>如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题.解决方法:有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。


## 3.性能问题
使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。“锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能

解决办法:
1. 第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。
2. 第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。

重要的性能指标

1. 吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。
2. 延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。
3. 并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。