## 全局锁

全局锁是针对整个数据库的锁，最长用的是读锁和写锁。

1. 读锁（共享锁）：它**阻止其他用户更新数据**，但是允许他们读取数据。在需要一段时间内保持数据的一致性很有用。
2. 写锁（排他锁）：他**阻止其他用户读取和更新数据**。在修改大量数据的时候可以使用。

**使用场景：**

用全局锁的时候一般是全库备份和全库导出的时候用。

## 表级锁

表级锁是Mysql最基本的锁策略，是最常采用的锁策略。特点是**加锁快，开销小，不会死锁；但是锁的粒度大，发生锁冲突的概率高，并发度最低**

1. 表共享读锁：同上，以表为单位
2. 表独占写锁：同上，以表为单位

**使用场景：**

- MylSAM的表的读操作会自动加上读锁，写操作的时候加上写锁。因为没有事务，所以需要用表锁来保证一致性
- innnoDb主要使用行锁来实现MVCC，MVCC能更好的提供并发性和更少的锁冲突

总体来说表锁适合读操作多写操作少的场景。写操作多的情况下表锁竞争会成为程序的瓶颈。

**会用到表锁的命令：**

- Alter table：修改表的结构
- drop table 和 truncate table 删除表和删除表的所有数据
- lock tables
- 全表扫描或者大范围的扫描：对于mylsam会触发表锁

**表锁的问题：**

1. 性能毫无疑问会下降很多
2. 并发性能很差。
3. 导致锁等待和锁超时。
4. 写操作会大量阻塞其他操作。
5. 表锁本身不会死锁，但是在多个表的操作中，如果没有按照一定的顺序获得锁，可能会导致死锁。



## 行锁

对单张表的单行数据会用到锁。粒度很小，因此在高并发的事务中可以提供更少的锁冲突。因为粒度细会用到更多的内存和cpu资源，因为需要每一行进行管理。

1. 共享锁：同上
2. 排他锁：同上

**使用场景：**

- 高并发的读写操作
- 单行操作
- 短期锁
- 实现并发控制：
- 复杂的事务管理

**会用到表锁的命令：**

- select ...for update：会添加一个排他锁
- select... lock in share mode，手动给你来一个贡献锁
- insert
- update
- delete

这些锁都是在事务中进行的，在事务开始上锁，在commit或者回滚的时候解锁。如果不是在事务中，执行完一条语句会自动的解锁。

**表锁的问题：**

1. 死锁
2. 锁等待
3. 锁升级：会给你自动升级成表锁，发生了更多的锁冲突
4. 资源消耗
5. 难以调试和排查
6. 事务隔离级别



## 意向锁

意向锁为了协调表锁和行锁的关系，支持多粒度的锁并存。

当事务A有了行锁，Mysql会自动为该表添加有意向锁，事务B如果想要申请这个表的写锁，那么不需要遍历每一行来判断是否存在行锁，而是直接判断是否存在意向锁，增加了性能。

**意向锁为什么是表级锁？**

如果我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）。

（1）如果意向锁是行锁需要我们一行一行的去判断

（2）如果是表锁我们只需要判断一次就可以了

**意向锁怎么支持表锁和行锁的并存？**

（1）并存是指数据库同时支持表锁，行锁，而不是任何情况都支持一个表中同时有一个事务A同时持有行锁，又有一个事务B持有表锁。因为一旦一个表被上了一个表级的写锁，肯定不能在上一个行级锁

（2）如果事务A对一行上锁了，其他事务就不可能修改这一行了，这与事务B锁住了整个表就能任意修改表中的任意一行冲突。所以，没有意向锁的时候，让行锁和表锁共存，就会带来很多问题。于是有了意向锁。

![image-20240529190510868](./page/image-20240529190510868.png)

## 间隙锁

间隙锁锁定的不是具体的行记录，而是两个索引之间的间隙，这样可以防止新的记录插入到该间隙，确保数据的一致性和事务的隔离性。

间隙锁常常和记录锁一起使用，共同形成了Next-Key锁，保护索引记录的范围查找和扫描操作

**下面是间隙锁的主要类型：**

1. 区间-区间间隙锁：锁定两个索引键之间的间隙，或者第一个索引键之间的间隙。
2. 区间-记录间隙锁：锁定一个索引键和一个记录之间的间隙。
3. 记录-区间间隙锁：锁定一个记录和一个索引键之间的间隙。

间隙锁主要是解决幻读问题。至于幻读是什么请详细看mvcc解决的各种读问题。

值得注意的是，由于间隙锁会锁定范围，如果并发事务较多且涉及的数据范围有交集，可能会引发性能问题，甚至死锁。因此在设计数据库和选择隔离级别时，需要综合考虑数据一致性和并发性能。

**间隙锁的使用场景：**

1. 防止幻读
2. 范围查询：执行范围查询期间保证不会有新的数据会插入新的数据。



**间隙锁的问题：**

1. 性能
2. 死锁风险
3. 复杂性
4. 锁定范围过大



## 临键锁

![image-20240529192220052](./page/image-20240529192220052.png)

![image-20240529192413375](./page/image-20240529192413375.png)