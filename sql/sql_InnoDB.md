[TOC]
# 1.主索引(聚簇索引)
![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/jib.png)
上图是InnoDB搜索数据的示例,具体看网盘的4-4
>- 他的数据结构和B+树并不是完全一样,同层节点增加了指针,构成了双向链表,方便了范围查找
>- 节点中并不是数据而是指向数据方向的索引,叶子节点中直接存放数据每个叶子节点存放的链表,每个叶子节点又组成了一个节点链表

# 2.辅助索引
结构几乎和主索引相同,但是key变成了辅助索引的值,而叶子结点也不是存的数据而是存在主索引,在根据主索引查一遍来获取数据

# 3.逻辑存储结构
- 表空间 (数据表在磁盘上的存储空间,默认所有表的数据都存在共享的空间,推荐每个表放在单独的独占表空间ibd文件)
  - 叶子结点的段(数据段)
  - 非叶子节点段(索引段)
- 段
- 区(64个页)
- 页(16kb, 下限指针,上限指针,行记录)
> **页为什么不能太大?或者太小**
> 页是InnoDB读写磁盘的最小结构(将整个页数据读到内存中,然后再去找数据,16MB对内存太大了,一个16MB的链表太长了),如果太大了,那么对InnoDB读写会造成很大的负担.如果太小的话,机械盘或者SSD读写单位不能太小,不能用满硬盘的一个块,造成浪费
- 行
如下图所示:
![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/dad.png)

# 4.InnoDB的数据行
## InnoDB的变长列
>长度不固定的数据类型:VARCHAR, VARBINARY, BKOB, TEXT,占用空间大于768Byte的不变长类型:CHAR,边长编码下的CHAR,以上的占用磁盘空间不是固定的.
## 行溢出数据
>由于每个Page的容量是有限的,导致数据字段也是有限的,当数据过大的时候,行溢出机制会把超长的字段放入单独开辟的数据页中(BLOB).这么做相当于给行做了瘦身可以让页存放更多的行.所以如果是超长的数据是先到磁盘中取出页,找到这个数据所在的行,在进行一次io把这个行中的超长数据从磁盘中取出来.

## 行记录的格式
 现在用的最多的格式是**Dynamic**格式:
 ![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/sdaf.png)
 数据超过了40Byte直接溢出存放到BLoB中