[TOC]
# 覆盖索引
覆盖索引(联合索引)是指:查询语句从执行到返回结果均使用同一个索引,覆盖索引可以有效的减少回表
![](https://raw.githubusercontent.com/Haiyang-coder/ImageRepository/main/sdf.png)

>按照了最左前缀优先的原则,查询语句书写不当容易造成索引失效的情况.这也解释了为什么尽量少写select *,这样会造成回表操作,大大加大了查询的开销

# 如何走合适的索引
mysql在决定走哪条索引的时候会参考**索引基数**,这个基数是mysql估算的,表明了数据的区分情况
>比如学校学生用班级区分,这个班级的数量就是索引的基数,mysql一般采用估算的方式来获取基数情况

索引基数越大,表明了索引的
- 粒度更小
- 区分度更大
>mysql就更趋向于走这种索引.那如果查询的时候没有走我们预计的索引,一般就是mysql估测这个索引不是最佳索引

**解决的办法:**
- 重新估计区分度,也就是重新获取基数 analyze table
- 强制使用某一个索引

# count 性能怎么优化
**count函数**:统计结果集中数据不为null的个数,首先存储引擎查出结果集,server层逐个判断是否为null,累加出count的值.
**4种count的情况**
1. count(非索引字段):是最慢的,没有办法使用覆盖索引,先遍历每一个行的你选择的字段,然后解析行记录,发给server层判断是否为空.
2. count(索引字段):可以使用覆盖索引,但是还是要server来判断为空
3. count(1):不需要取出数据,直接返回1,但是server层依然需要判断时候为空
4. count(*):直接返回B+树的数据量,最快的


# order by 性能优化
**order by原理:**
- 用where等条件查询
- 将查询结果放入sort_buffer
- 对中间结果按照指定方式排序
- 回表生成完成的结果集(如果有需要)

**可以优化的地方**
- where后边可以走联合索引可以加快
- 当中间结果小的时候可以直接放在内存中,但是中间表大于sort_buffer_size,放到硬盘中.
- 中间结果集可以只有两个字段,一个排序字段一个主键,按照排序字段排序完成之后,对照着主键回表查询.回表的步骤会拖慢效率.**max_length_for_sort_data**,只有大于这个的时候才会用回表.但是这个值太大的话,会把中间表放到硬盘里,还不如回表来的快.
- 让排序走索引覆盖

# 随机选取Rand() 优化