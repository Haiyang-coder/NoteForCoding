# 多线程服务器

## 1 单线程服务器的两种模型 

- Reator模型

原理：以事件作为驱动，和事件回调的方式实现业务逻辑，下面是模型的主要部分：

1. **事件处理器（Event Handler）**：负责处理特定事件的逻辑。在 Reactor 模型中，通常会有一个或多个事件处理器，每个负责处理一类特定的事件，比如连接事件、读事件、写事件等。
2. **Reactor**：也称为事件分发器，负责监听和分发事件。Reactor 负责注册事件处理器，监听事件的到来，并将事件分发给对应的事件处理器进行处理。
3. **事件驱动**：Reactor 模型是基于事件驱动的，即程序通过监听和响应事件的方式进行工作。==他的事件是在内核态有的时候事件==
4. 还是同步IO，因为你还是自己将数据从内核态拷贝过来



- Proactor模型

Proactor 模型包含以下主要组件：

1. **事件处理器（Event Handler）**：仍然负责处理特定事件的逻辑，与 Reactor 模型中的事件处理器类似。
2. **Proactor**：是底层系统组件，负责监控 I/O 操作的完成，并通知应用程序。==内核已经将数据送到了用户空间了==
3. 他是异步IO，直接把数据给你拷贝到了用户态的内存区了 





## 2. 进程间通信

进程间通信只用socket通信（主要是用TCP）

为什么：

- 方便一个ip，一个port就可以通信了，可以传送大量的数据
- 防止程序重复启动，因为你独占port，所以一个进程只能用一个port
- 程序意外退出，操作系统会回收socket资源，不会留下垃圾，重启软件就好了，不用你重启机器了
- 两个tcp一个意外关闭了，操作系统会回收资源，tcp的另一个会马上感知到
- 跨语言，都会支持tcp







## 3. linux上对线程的标识

使用 `pthread_t` 有以下优点：

1. **专门为线程设计：** `pthread_t` 是 POSIX 标准定义的线程标识类型，更直接地表示线程。这是线程创建和管理的标准方法。
2. **更好的线程操作支持：** 使用 `pthread_t` 可以更方便地使用 POSIX 线程库提供的线程操作函数，如创建、等待、退出等。
3. **跨平台性：** 如果你的代码需要在不同的操作系统上运行，使用 `pthread_t` 更具可移植性，因为它是 POSIX 标准的一部分。

在简单的多线程应用程序中，通常建议使用 `pthread_t`。如果你有特殊需求，并且了解在Linux上使用 `clone` 系统调用等更底层的机制，那么你也可以选择使用 `pid_t`。然而，一般而言，使用 `pthread_t` 更为常见和推荐。



==注意：==

pthread_t：pthread_t的不同只能是处在同一个进程中才能看出来，所以如果是不同的进程中要标志不同的线程id，不宜使用pthread_t，我们推荐使用tid。

有时候我们可能需要直到进程的真实`pid`。比如进程P1要向另一个进程P2中的某个线程发送一个信号，我们既不能使用进程P2的pid，更不能使用线程的`pthread_id`，而只能使用该线程的真实pid，称为tid

有一个函数`gettid()`可以取得tid，但是glibc没有实现这个函数，只能通过linux的系统调用`syscall`来获取`syacall(SYS_gettid)`



## 4. 服务器上的性能杀手

1. 数据拷贝：应对方式：增加缓存
2. 环境切换：这里指的是线程的反复切换申请：可以用线程池和判断是否你的业务场景真的适用于多线程
3. 内存分配：要用内存池，避免内存的申请和释放导致的性能瓶颈
4. 锁竞争：这个无需多言





## 5. 惊群效应

**惊群效应简介**
所谓惊群效应，就是多个进程或者线程在等待同一个事件，当事件发生时，所有进程或者线程都会被内核唤醒。然后，通常只有一个进程获得了该事件，并进行处理；其他进程在发现获取事件失败后，又继续进入了等待状态。这在一定程度上降低了系统性能。

具体来说，惊群通常发生在服务器的监听等待调用上。服务器创建监听socket，然后fork多个进程，在每个进程中调用accept或者epoll_wait等待终端的连接。

**惊群的坏处**
惊醒所有进程/线程，导致n-1个进程/线程做了无效的调度、上下文切换，cpu瞬时增高。
多个进程/线程争抢资源，所以涉及到同步问题，需对资源进行加锁保护，加解锁加大系统CPU开销。

**惊群的几种情况**
在高并发（多线程/多进程/多连接）中，会产生惊群的情况有：

- accept惊群
- epoll惊群
- nginx惊群
- 线程池惊群

https://blog.csdn.net/fengyuyeguirenenen/article/details/123820590



## 6.multiple reactors

注意reator这里是网络io，就是网络请求，用这个模式能够很好的做到网络io的均衡

要想在高并发的网络io还能处理任务处理的快速，就要加上线程池了。就可以==高并发网络io+高密集的计算请求==，这也是muduo所推荐的模型

**linux能有有多少链接**

还有就是高并发连接，怎么算你的机器能达到的最大连接数呢？我说的是连接数，不考虑网络因素。这个和你的内存有关。你的一个链接消耗一个socket，一个socket多少字节，你的内存除以这个字节数，就是==理论上==最大的链接数。但是一般会远小于这个链接数。因为你的电脑其他任务也会消耗内存。所以一个1g的内存能达到十万已经很好了。

**分配多少reactor**

我现在做的异常数据汇聚系统就是一个这个模型。这个模型要设计多少个reator呢，一般来说，一个千兆网口分配一个reactor

**linux可以同时启动多少个线程**

一个默认线程栈：10M

一个32位的系统，用户可以访问的地址空间为：3G左右

所以一个进程最多能同时启动300个线程左右，这也就意味着，服务器同时最多可以同时处理300个网络io的请求

**线程池的大小如何选择**

要看你线程中做的操作占你cpu的工作的比重，如果你线程中的工占了整个cpu工作的二分之一，你有8个cpu，那你就用16个线程就可以让cpu满负荷运转