# 多线程服务器

## 1 单线程服务器的两种模型 

- Reator模型

原理：以事件作为驱动，和事件回调的方式实现业务逻辑，下面是模型的主要部分：

1. **事件处理器（Event Handler）**：负责处理特定事件的逻辑。在 Reactor 模型中，通常会有一个或多个事件处理器，每个负责处理一类特定的事件，比如连接事件、读事件、写事件等。
2. **Reactor**：也称为事件分发器，负责监听和分发事件。Reactor 负责注册事件处理器，监听事件的到来，并将事件分发给对应的事件处理器进行处理。
3. **事件驱动**：Reactor 模型是基于事件驱动的，即程序通过监听和响应事件的方式进行工作。==他的事件是在内核态有的时候事件==
4. 还是同步IO，因为你还是自己将数据从内核态拷贝过来



- Proactor模型

Proactor 模型包含以下主要组件：

1. **事件处理器（Event Handler）**：仍然负责处理特定事件的逻辑，与 Reactor 模型中的事件处理器类似。
2. **Proactor**：是底层系统组件，负责监控 I/O 操作的完成，并通知应用程序。==内核已经将数据送到了用户空间了==
3. 他是异步IO，直接把数据给你拷贝到了用户态的内存区了 





## 2. 进程间通信

进程间通信只用socket通信（主要是用TCP）

为什么：

- 方便一个ip，一个port就可以通信了，可以传送大量的数据
- 防止程序重复启动，因为你独占port，所以一个进程只能用一个port
- 程序意外退出，操作系统会回收socket资源，不会留下垃圾，重启软件就好了，不用你重启机器了
- 两个tcp一个意外关闭了，操作系统会回收资源，tcp的另一个会马上感知到
- 跨语言，都会支持tcp







## 3. linux上对线程的标识

使用 `pthread_t` 有以下优点：

1. **专门为线程设计：** `pthread_t` 是 POSIX 标准定义的线程标识类型，更直接地表示线程。这是线程创建和管理的标准方法。
2. **更好的线程操作支持：** 使用 `pthread_t` 可以更方便地使用 POSIX 线程库提供的线程操作函数，如创建、等待、退出等。
3. **跨平台性：** 如果你的代码需要在不同的操作系统上运行，使用 `pthread_t` 更具可移植性，因为它是 POSIX 标准的一部分。

在简单的多线程应用程序中，通常建议使用 `pthread_t`。如果你有特殊需求，并且了解在Linux上使用 `clone` 系统调用等更底层的机制，那么你也可以选择使用 `pid_t`。然而，一般而言，使用 `pthread_t` 更为常见和推荐。





## 4. 服务器上的性能杀手

1. 数据拷贝：应对方式：增加缓存
2. 环境切换：这里指的是线程的反复切换申请：可以用线程池和判断是否你的业务场景真的适用于多线程
3. 内存分配：要用内存池，避免内存的申请和释放导致的性能瓶颈
4. 锁竞争：这个无需多言